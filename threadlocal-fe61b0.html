<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>ThreadLocal&nbsp;|&nbsp;沂风</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="ThreadLocal">
  
    <meta name="description" content="java中的并发解决方案之一：threadlocal">
    <meta property="og:description" content="java中的并发解决方案之一：threadlocal">
  
  
    <meta property="og:image" content="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🧵&lt;/text&gt;&lt;/svg&gt;">
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>关于</span>
        </div>
      </a>
    
  
    
  
</nav>
  <header class="Header">
    
      <div class="Header__Cover">
        <img src="https://www.notion.so/images/page-cover/gradients_5.png">
      </div>
    
    <div class="Header__Spacer ">
    </div>
    
      <div class="Header__Icon">
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🧵&lt;/text&gt;&lt;/svg&gt;"></span>
      </div>
    
    <h1 class="Header__Title">ThreadLocal</h1>
    
      <div class="DateTagBar">
        
          <span class="DateTagBar__Item DateTagBar__Date">Posted on Fri, Sep 1, 2023</span>
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--red">
            <a href="tag/JUC.html">JUC</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/fe61b04d25b24316b5eeadda79463fbb" class="PageRoot"><ul id="https://www.notion.so/84fa303ab0054a0dbd045aa087330c87" class="ColorfulBlock ColorfulBlock--ColorGray TableOfContents"><li class="TableOfContents__Item"><a href="#https://www.notion.so/c0e6379c50834dd99a96b1fd08f33917"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用ThreadLocal来维护变量时, ThreadLocal会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/fe9c83f9bc5045d1a0cf4edfeceea313"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">简单使用</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/d336ecaf4d6e44d6b92b3af2dcef990b"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">原理</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/b1372a4344184bb5bf223f0ab7a6bcc2"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">每个线程都有自己的ThreadLocalMap对象（threadlocals），类似于Map，键为threadlocal</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/3d4edd2e9804404993442d838c52b606"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">实际的值存储在线程内部，threadlocal是入口</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/0f2b66afaf514557ac5a220c01a2eb93"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ThreadLocalMap对象是什么</strong></strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/a51675931d694ffe89ea99bb141e9028"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">Threadlocal和Synchronized的区别</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/f864b2eb06774dabab7b2aad6ca87a66"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal是如何为每个线程创建变量副本的</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/1495c395afc44777bbb59487828b30b2"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">应用场景</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/9e6f57bd8e3b4330994ed7d6fd4a42f9"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">内存泄漏</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/dc4fc7ec64014c01bcda3ec2d91ab457"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">为什么key要使用弱引用</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/f0fb3be6c8934d0a9a2ab0d9e8af0984"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">真正的问题是，线程对象不被回收，这就发生真正意义上的内存泄漏。比如使用线程池的时候，线程结束是不会被销毁的</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/bf7bd59946e34254b557b8c66a365433"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">局限性</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/c2018e81f2ec4859b126785742387a81"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">hreadLocal不能解决共享变量的</strong></strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">线程安全</strong></strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">问题</strong></strong></span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/ccad1fb8586c4d9a9f9e03f0181a2e3f"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal与开放地址法</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/33ae5322fbc343308855a15a47ef3639"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">参考资料</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/60fdea3ce5bb486c846dda7e2bcc4262"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">特殊的删除</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/e25ba763754341e6bd46d6c11d825516"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">参考资料</span></span></div></a></li></ul><div id="https://www.notion.so/c0e8949885d24bdd91006a4c2879ee5a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性</span></span></p></div><div id="https://www.notion.so/fdf8d9156f8340969c0b7e4399cb0820" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ThreadLoacl是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法（不一定）</span></span></p></div><div id="https://www.notion.so/ea77b6a285654e5b94a3ce736ec8dac8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当我们创建一个变量之后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题</span></span></p></div><h3 id="https://www.notion.so/c0e6379c50834dd99a96b1fd08f33917" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/c0e6379c50834dd99a96b1fd08f33917"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用ThreadLocal来维护变量时, ThreadLocal会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。</span></span></h3><h1 id="https://www.notion.so/fe9c83f9bc5045d1a0cf4edfeceea313" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/fe9c83f9bc5045d1a0cf4edfeceea313"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">简单使用</span></span></h1><div id="https://www.notion.so/2746fce5f47942f2b9a0384b4bf3dd83" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3f21c8b0-c40f-408e-9be8-ead48725c3da%2FUntitled.png?width=1104&amp;table=block&amp;id=2746fce5-f479-42f2-b9a0-384b4bf3dd83"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3f21c8b0-c40f-408e-9be8-ead48725c3da%2FUntitled.png?width=1104&amp;table=block&amp;id=2746fce5-f479-42f2-b9a0-384b4bf3dd83" style="width:1104px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/d52b9df4bb30401ab9bdbc2196e1215e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/cf41ed4b351f4f1b91334d8fcd9b94c2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/7a6e75fef2644fb1b08814d9efba32b5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">threadlocal是一个线程内部的存储类，可以在指定线程内存储数据，数据存储之后，只有指定线程可以得到数据</span></span></p></div><h1 id="https://www.notion.so/d336ecaf4d6e44d6b92b3af2dcef990b" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/d336ecaf4d6e44d6b92b3af2dcef990b"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">原理</span></span></h1><div id="https://www.notion.so/a325efa1ace143ddb058af7d83ce1180" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal的静态内部类ThreadLoaclMap为每个Thread都维护了一个数组table，ThreadLoacl确定了一个数组下标，而这个下标就是value存储的对应位置</span></span></p></div><div id="https://www.notion.so/5285eee7e8fb440cb07b198e883a54bc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个线程都有自己的ThreadLocalMap对象</span></span></p></div><h3 id="https://www.notion.so/b1372a4344184bb5bf223f0ab7a6bcc2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/b1372a4344184bb5bf223f0ab7a6bcc2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">每个线程都有自己的ThreadLocalMap对象（threadlocals），类似于Map，键为threadlocal</span></span></h3><h3 id="https://www.notion.so/3d4edd2e9804404993442d838c52b606" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/3d4edd2e9804404993442d838c52b606"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">实际的值存储在线程内部，threadlocal是入口</span></span></h3><div id="https://www.notion.so/f1be802266aa458fa938449105902a1d" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd8ac3c29-a082-439d-9a9b-32cb471118e3%2FUntitled.png?width=1216&amp;table=block&amp;id=f1be8022-66aa-458f-a938-449105902a1d"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd8ac3c29-a082-439d-9a9b-32cb471118e3%2FUntitled.png?width=1216&amp;table=block&amp;id=f1be8022-66aa-458f-a938-449105902a1d" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/236727a7ff6348e2a47833d9fe8961dc" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1dccda78-0b46-48f3-877e-938e84812891%2FUntitled.png?width=1216&amp;table=block&amp;id=236727a7-ff63-48e2-a478-33d9fe8961dc"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1dccda78-0b46-48f3-877e-938e84812891%2FUntitled.png?width=1216&amp;table=block&amp;id=236727a7-ff63-48e2-a478-33d9fe8961dc" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h2 id="https://www.notion.so/0f2b66afaf514557ac5a220c01a2eb93" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/0f2b66afaf514557ac5a220c01a2eb93"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ThreadLocalMap对象是什么</strong></strong></span></span></h2><div id="https://www.notion.so/d01375c1932b4c06a4228400a3716a07" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">本质上来讲, 它就是一个Map, 但是这个ThreadLocalMap与我们平时见到的Map有点不一样</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/2b2b5458b9d44f249123907e1f4ba69c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">它没有实现Map接口;</span></span></li><li id="https://www.notion.so/f816d8422b65430c861ca02ad449c006" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">它没有public的方法, 最多有一个default的构造方法, 因为这个ThreadLocalMap的方法仅仅在ThreadLocal类中调用, 属于静态内部类</span></span></li><li id="https://www.notion.so/59e25f084cf1477b8366787eb31e63ec" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">ThreadLocalMap的Entry实现继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span></span></li><li id="https://www.notion.so/d56669c3fe0240a990ca93dd907b4640" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">该方法仅仅用了一个Entry数组来存储Key, Value; Entry并不是链表形式, 而是每个bucket里面仅仅放一个Entry;</span></span></li></ul><div id="https://www.notion.so/6d6c554d4d784cc99056c44fae60ae9c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/a51675931d694ffe89ea99bb141e9028" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/a51675931d694ffe89ea99bb141e9028"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Threadlocal和Synchronized的区别</span></span></h1><ol class="NumberedListWrapper"><li id="https://www.notion.so/85d04c70022a4dccb1ac342adc4d863e" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">Synchronized是通过线程等待，牺牲时间来解决访问冲突</span></span></li><li id="https://www.notion.so/8d9e29d6f76b40de95b90ae7b496f766" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal是每个线程单独一份存储空间，牺牲空间来解决冲突</span></span></li></ol><div id="https://www.notion.so/07d11678c8124ea2a1b51ff840c6c5e0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal具有线程隔离性，当某些数据是以线程为作用域并且不同线程具有不同的数据副本时，就可以考虑使用ThreadLocal</span></span></p></div><h1 id="https://www.notion.so/f864b2eb06774dabab7b2aad6ca87a66" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/f864b2eb06774dabab7b2aad6ca87a66"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal是如何为每个线程创建变量副本的</span></span></h1><ol class="NumberedListWrapper"><li id="https://www.notion.so/c229bfee926e4607b953c2e961b4044e" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">生成一个ThreadLocalMap类型的成员变量threadLoacls</span></span></li><li id="https://www.notion.so/f8a508a60373462fbca05030abd16e17" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">实例化属性初始化的时候就调用set方法，进行kv初始化</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/2215b89bdbfb4f31aab2e3f9c814d334" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">获取当前线程</span></span></li><li id="https://www.notion.so/7eb5f1f2f6694981a3267555538e75e7" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">依据当前线程，获取threadLoaclMap的实例（在thread中维护）</span></span></li><li id="https://www.notion.so/48cce0f00fd743be80451ff28ca147fd" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">如果实例存在，则进行set操作</span></span></li><li id="https://www.notion.so/bb8e27a4137d42beb8dbe001fae7e9da" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">实例不存在就进行初始化</span></span></li></ol></li><li id="https://www.notion.so/d90144a0fa2147db810dd7809ad87a09" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">后续对ThreadLocal修饰的变量进行修改，修改之后会重新set到成员变量threadLocals</span></span></li><li id="https://www.notion.so/0d951e8e9bf74c7a845e133965e0bc3a" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">自始至终所有操作都是在线程内存中完成的</span></span></li></ol><div id="https://www.notion.so/399c40664c664a959dcc96c1886460bc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/1495c395afc44777bbb59487828b30b2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/1495c395afc44777bbb59487828b30b2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">应用场景</span></span></h1><div id="https://www.notion.so/821d38acfef840f593903a36dfb5332e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">用来解决数据库链接，Session管理等，tomcat</span></span></p></div><h1 id="https://www.notion.so/9e6f57bd8e3b4330994ed7d6fd4a42f9" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/9e6f57bd8e3b4330994ed7d6fd4a42f9"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">内存泄漏</span></span></h1><div id="https://www.notion.so/cd9c8b7c88534de7a624a572df1682ad" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/240e3a684e9543d2a03bd56781ca75f0" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F15cb6843-a25a-4267-ae78-ed38993c3242%2FUntitled.png?width=1280&amp;table=block&amp;id=240e3a68-4e95-43d2-a03b-d56781ca75f0"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F15cb6843-a25a-4267-ae78-ed38993c3242%2FUntitled.png?width=1280&amp;table=block&amp;id=240e3a68-4e95-43d2-a03b-d56781ca75f0" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/03e8ff9653e740bfbc487f1257a9bc7e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/d34a9c25fd944ca5906e41c252849e07" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</span></span></p></div><div id="https://www.notion.so/c283d7ea097a4044a50013f7803a18f3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">但是使用</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">弱引用</strong></span><span class="SemanticString">可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。</span></span></p></div><div id="https://www.notion.so/ac3dc435c8964ddc811d4e6e44278fde" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</span></span></p></div><h2 id="https://www.notion.so/dc4fc7ec64014c01bcda3ec2d91ab457" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/dc4fc7ec64014c01bcda3ec2d91ab457"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">为什么key要使用弱引用</span></span></h2><div id="https://www.notion.so/dc9eb061bf914f5d84fd0327e50eb199" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个弱引用都指向threadlocal（指key是弱引用）</span></span></p></div><div id="https://www.notion.so/0f79b6b420174d5da12bd3c41aa35d0f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">但是，如果key强引用指向threadlocal，那么这个threadlocal就会因为和entry存在强引用关系导致无法被回收。造成内存泄漏</span></span></p></div><div id="https://www.notion.so/feac355eb0f745c59f41ff681229f1fd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/f0fb3be6c8934d0a9a2ab0d9e8af0984" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/f0fb3be6c8934d0a9a2ab0d9e8af0984"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">真正的问题是，线程对象不被回收，这就发生真正意义上的内存泄漏。比如使用线程池的时候，线程结束是不会被销毁的</span></span></h2><div id="https://www.notion.so/da436b7489c74f1481bfce7b674259ad" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/d2a95111d05549a783a3faab0750e97b" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F453dc539-ea7c-4796-8bc1-6f24fee6b9ed%2FUntitled.png?width=1280&amp;table=block&amp;id=d2a95111-d055-49a7-83a3-faab0750e97b"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F453dc539-ea7c-4796-8bc1-6f24fee6b9ed%2FUntitled.png?width=1280&amp;table=block&amp;id=d2a95111-d055-49a7-83a3-faab0750e97b" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/8463a299f5f8495bb95a763bc22c7ae2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/bf7bd59946e34254b557b8c66a365433" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/bf7bd59946e34254b557b8c66a365433"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">局限性</span></span></h1><div id="https://www.notion.so/97fb977eba2a4b9c81a08f370c8cb5e8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">子线程无法获取ThreadLocal中的值</span></span></p></div><h2 id="https://www.notion.so/c2018e81f2ec4859b126785742387a81" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/c2018e81f2ec4859b126785742387a81"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">hreadLocal不能解决共享变量的</strong></strong></span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&amp;spm=1001.2101.3001.7020"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">线程安全</strong></strong></a></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">问题</strong></strong></span></span></h2><h1 id="https://www.notion.so/ccad1fb8586c4d9a9f9e03f0181a2e3f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/ccad1fb8586c4d9a9f9e03f0181a2e3f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal与开放地址法</span></span></h1><h2 id="https://www.notion.so/33ae5322fbc343308855a15a47ef3639" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/33ae5322fbc343308855a15a47ef3639"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">参考资料</span></span></h2><div id="https://www.notion.so/f8bfff6fe5ab4a52a1d116ddc1ec7726" class="Bookmark"><a href="https://zhuanlan.zhihu.com/p/341678034"><h5 class="Bookmark__Title">开放寻址的ThreadLocalMap分析</h5><p class="Bookmark__Desc">什么是散列散列表(hash table)我们平时也叫它哈希表或者Hash表，它用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，没有数组就没有散列表。 比如我们有100…</p><p class="Bookmark__Link">https://zhuanlan.zhihu.com/p/341678034</p></a></div><div id="https://www.notion.so/693dbe0f5c8f45f5a23e8e8ceb4e04de" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">使用开放地址法</span></span></p></div><div id="https://www.notion.so/6e76616f0ddc4f6cb043a8dd5871687c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">开放寻址法的核心是如果出现了散列冲突，就重新探测一个空闲位置，将其插入。当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</span></span></p></div><div id="https://www.notion.so/d4ec5983bb64498eb88932c50c5286e0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h3 id="https://www.notion.so/60fdea3ce5bb486c846dda7e2bcc4262" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/60fdea3ce5bb486c846dda7e2bcc4262"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">特殊的删除</span></span></h3><div id="https://www.notion.so/cd0f16eb580945deaaef1a6db0a13fda" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/e25ba763754341e6bd46d6c11d825516" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/e25ba763754341e6bd46d6c11d825516"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">参考资料</span></span></h1><div id="https://www.notion.so/85ad56db6ce94451894844ead6c7c2ea" class="Bookmark"><a href="https://blog.csdn.net/f641385712/article/details/104573489"><h5 class="Bookmark__Title">ThreadLocal能解决线程安全问题？胡扯！本文教你正确的使用姿势【享学Java】_YourBatman的博客-CSDN博客</h5><p class="Bookmark__Desc">`ThreadLocal`：线程 + 本地 -&gt; **线程本地变量**（所以说我觉得它取名叫`ThreadLocalVariable`获取还更能让人易懂些），它的出镜率可不低。虽然写业务代码一般用不着，但它是开源工具的常客：用于在**线程生命周期内**传递数据。有的人说，每看一遍`ThreadLocal`都会有新的感受，这其实是比较诡异的现象，因为我认为“真理”是不应该经常变的（或者说是不可能变化的）。我自己百度了一波，关于`ThreadLocal`的文章满天飞，有讲使用的亦有讲原理的，鱼龙混杂。其中有</p><p class="Bookmark__Link">https://blog.csdn.net/f641385712/article/details/104573489</p></a></div></article>
  <footer class="Footer">
  <div>&copy; 沂风 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>